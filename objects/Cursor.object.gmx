<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>CursorSprite</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-100</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>gridSize = 24;    // Set as power of 2 (1,2,4,8,16,32...)
isMoving = false; // True when player walking on grid
moveTimer = 0;    // Set to gridSize when move start
moveSpeed = 4;    // Set as something that goes evenly into grid size.
speedX = 0;       // horizontal walking speed
speedY = 0;       // vertical walking speed


// Helpful for setting state after moving
justStoppedMoving = true;

CanMove = true;

List = 0; //For switching between attackable enemies
State = 'off'; //State -1 means nothing happens.

NumberOfGuys = 0; //Total number of players / enemies on the map. It gets changed automatically.
TurnOrder[0] = 0; //The turn order. It gets filled and sorted when the room starts or at the end of a round.
AttackList[0] = 0;
CurrentTurn = 0;
CurrentTarget = 0;
NumberOfTargets = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Cursor.State = 'ManualMovement';//allow cursor to move
Cursor.visible = true;//Show Cursor
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_perform(ev_other,ev_user1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//===========================================
//=If we are moving the cursor around freely=
//===========================================
room_caption = string(fps);
if(State = 'ManualMovement'){//If we can move the cursor around the map.
    if (justStoppedMoving = true){
        justStoppedMoving = false;
    }
    //When not moving, check to see if a direction key is held.
    if(CanMove){
        if (isMoving = false){        
                 // Perform 8 direction keyboard and grid checks
                 // for setting appropriate movement and animation
            if (keyboard_check(global.RightButton)&amp;&amp;keyboard_check(global.UpButton)){
                if(((y-gridSize) &gt;= 0)&amp;&amp;((x+gridSize) &lt; room_width)){//Change to test for room border
                    isMoving = true;      // Lets start moving
                    moveTimer = gridSize; // Ready moveTimer for countdown
                    speedX = moveSpeed;   // Set horizontal speed
                    speedY = -moveSpeed;  // Set vertical speed
                }
                else if((x+gridSize) &lt; room_width){
                    isMoving = true;      // Lets start moving
                    moveTimer = gridSize; // Ready moveTimer for countdown
                    speedX = moveSpeed;   // Set horizontal speed
                    speedY = 0;           // Set vertical speed
                }
                else if((y-gridSize) &gt;= 0){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = 0;
                    speedY = -moveSpeed;
                }
            }
            else if (keyboard_check(global.DownButton)&amp;&amp;keyboard_check(global.LeftButton)){
                if(((y+gridSize) &lt; room_height)&amp;&amp;((x-gridSize) &gt;= 0)){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = -moveSpeed;
                    speedY = moveSpeed;
                }
                else if((y+gridSize) &lt; room_height){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = 0;
                    speedY = moveSpeed;
                }
                else if((x-gridSize) &gt;= 0){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = -moveSpeed;
                    speedY = 0;
                } 
            }
            else if (keyboard_check(global.LeftButton)&amp;&amp;keyboard_check(global.UpButton)){
                if(((y-gridSize) &gt;= 0)&amp;&amp;((x-gridSize) &gt;= 0)){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = -moveSpeed;
                    speedY = -moveSpeed;
                }
                else if((y-gridSize) &gt;= 0){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = 0;
                    speedY = -moveSpeed;
                } 
                else if((x-gridSize) &gt;= 0){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = -moveSpeed;
                    speedY = 0;
                } 
            }
            else if (keyboard_check(global.DownButton)&amp;&amp;keyboard_check(global.RightButton)){
                if(((y+gridSize) &lt; room_height)&amp;&amp;((x+gridSize) &lt; room_width)){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = moveSpeed;
                    speedY = moveSpeed;
                }
                else if((x+gridSize) &lt; room_width){
                    isMoving = true;      // Lets start moving
                    moveTimer = gridSize; // Ready moveTimer for countdown
                    speedX = moveSpeed;   // Set horizontal speed
                    speedY = 0;           // Set vertical speed
                }
                else if((y+gridSize) &lt; room_height){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = 0;
                    speedY = moveSpeed;
                }
            }
            else if (keyboard_check(global.RightButton)){
                if((x+gridSize) &lt; room_width){
                    isMoving = true;      // Lets start moving
                    moveTimer = gridSize; // Ready moveTimer for countdown
                    speedX = moveSpeed;   // Set horizontal speed
                    speedY = 0;           // Set vertical speed
                }
            }
            else if (keyboard_check(global.UpButton)){
                if((y-gridSize) &gt;= 0){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = 0;
                    speedY = -moveSpeed;
                }
            }
            else if (keyboard_check(global.LeftButton)){
                if((x-gridSize) &gt;= 0){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = -moveSpeed;
                    speedY = 0;
                } 
            }
            else if (keyboard_check(global.DownButton)){
                if((y+gridSize) &lt; room_height){
                    isMoving = true;
                    moveTimer = gridSize;
                    speedX = 0;
                    speedY = moveSpeed;
                }
            }
        }
    }
    
    // When Cursor is moving on grid...
    if (isMoving = true){
        x += speedX; // update our x/y positions
        y += speedY;
        moveTimer -= moveSpeed; // countdown moveTimer until 0, then stop moving
        if (moveTimer &lt;= 0){
            isMoving = false;
            justStoppedMoving = true;
        }
    }
}
//it should, (theoretically) fix floating point issues
x = round(x);
y = round(y);


//Key Event Listeners
//Select
if (keyboard_check_pressed(global.SelectButton)){
    //if cursor can move and stopped moving...
    if((State = 'ManualMovement')&amp;&amp;(!isMoving)){
        var CurrentCharacter;
        CurrentCharacter = instance_position(round(x),round(y),objGuy)
        
        if(CurrentCharacter = noone){
            State = 'off'; //Make sure the cursor doesnt do something stupid
            visible = false; //Cursor becomes invisible;
            //Create the cursor Menu
            instance_create(0,0,CursorMenuControler);
            with(CursorMenuControler){
                MenuAnimTop = -1;
                sound_play(MenuPanSound);
                MenuPanY = 100//Start at the bottom.
                PanDirection = 'up';
            }
        }
        else{
            //Display the character's status page
            visible = false; //Hide cursor.
            State = 'Status';
            instance_create(0,0,StatusPageBattleControler);
            with(StatusPageBattleControler){
                CurrentObject = Cursor;
                Character = CurrentCharacter;
                Display = true;
                PanDirection = 'in';
                sound_play(MenuPanSound);
            }
        }
    }
}

//Back
if (keyboard_check_pressed(global.BackButton)){
    if((State = 'ManualMovement')&amp;&amp;(!isMoving)){
        event_perform(ev_other,ev_user0);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="22">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//User 12 recieves calls from status controler
State = 'ManualMovement';
visible = true;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="12">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//reveal hidden units
/*
if(TestForHiddenReveal()){

}

//tests if we have to reveal any hidden units
//instance_activate_object(objGuy);//activate all 'hidden units'
var Character;
with(objGuy){
    if((Hidden)&amp;&amp;(RevealID &gt;= global.BattleState)){//is it time to reveal?
        if(!instance_place(round(x),round(y),objGuy)){//is there another character on this tile?
            Character = self.id;
            break;
        }
    }
}


AStar_init(global.RoomCellWidth,global.RoomCellHeight,24,24,0,0,1,0,-2,-2,0,0);
myPath = -1;
with (objCell){
    AStar_setBlocked(x,y,0);//Unblocks every cell. (Cursor doesnt have a move range)
}
myPath = AStar_findPath(x,y,ii.x,ii.y,0);
path_start(myPath,6,0,0);
xstart = x;
ystart = y;
State = 'TurnPathfinding';//State -1 means the cursor cant interact with anything, nor can the player push buttons to call cursor functions.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var ii; //The Current guy
visible = true;
//========================================
//=Looking for a character to pathfind to=
//========================================
if (State = 'LookingToPathfind'){ //State 0 = Looking for a guy to pathfind to.
/*
    if (CurrentTurn &gt;= NumberOfGuys){//If everyone had a turn, start a new cycle.
        //NumberOfGuys = instance_number(objGuy);//Number of remaining guys
        FillTurnList();
        SortTurnList();
        CurrentTurn = 0;
    }*/
    if (CurrentTurn &gt;= NumberOfGuys){//If everyone had a turn, start a new cycle.
        ii = noone;
    }
    else{
        ii = TurnOrder[CurrentTurn];//Who's turn it is
    }
    while(ii = noone){ //In case ii (the current guy) is dead, cycle through the list until we find an alive one
        CurrentTurn += 1;
        if (CurrentTurn &gt;= NumberOfGuys){//If everyone had a turn, start a new cycle.
            //NumberOfGuys = instance_number(objGuy);//Number of remaining guys
            //if(TestForHiddenReveal()){
                //event_perform(ev_other,ev_user2);//reveal hidden units
                //exit;//dont perform other actions
            //}
            FillTurnList();
            SortTurnList();
            CurrentTurn = 0;
        }
        ii = TurnOrder[CurrentTurn];//Who's turn it is
    }

event_perform(ev_other, ev_user0); //Pathfind to character

    //event_perform(ev_other, ev_user1); //Pathfind to character
}


/*
activate all instances.
if 'hidden'
if(reveal state = global.battle state)
if(no one on location)
tell cursor to pathfind to that target

test for hidden reveal
activate all
if a unit can be revealed
return true
if not, deactivate all hidden units and return false
*/





//TestForHiddenReveal
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Makes the cursor move to the guy who's turn it is. 

var ii;
ii = TurnOrder[CurrentTurn];//Who's turn it is
if(ii != noone){
    var character_exists = false;
    with(objGuy){ 
        if(id = ii){
            character_exists = true;
            break; 
        }
    }
    if(character_exists){
        if((round(Cursor.x) = round(ii.x))&amp;&amp;(round(Cursor.y) = round(ii.y))){//if cursor is already on the guy dont bother pathfinding.
            visible = false;
            State = 'none';//State 1 = character movement probs not needed?
            Cursor.x = round(ii.x); //Set cursor to exact player location in case of the path failing.
            Cursor.y = round(ii.y); //Sometimes it bugs out and stops at say 100.00 instead of 100. 
            with (ii){ //Toggle character's ability to move
                IsTurn = true;
                event_perform(ev_other,ev_user0); //Find Move Range.
            }
            //Menu Slide function
            with(BattleControler){
                HUDPan = 200;//BattleHUD
                LEPan = -200;//LandEffect
                event_perform(ev_other,ev_user1);
                BattleControler.Display = true; //Draw BattleHUD
                BattleControler.HUDPanDirection = 'in'; //Slide Menus in.
                sound_play(MenuPanSound);
            }
        }
        else{//We have to pathfind to the character
            AStar_init(global.RoomCellWidth,global.RoomCellHeight,24,24,0,0,1,0,-2,-2,0,0);
            myPath = -1;
            with (objCell){
                AStar_setBlocked(x,y,0);//Unblocks every cell. (Cursor doesnt have a move range)
            }
            myPath = AStar_findPath(x,y,ii.x,ii.y,0);
            path_start(myPath,6,0,0);
            xstart = x;
            ystart = y;
            State = 'TurnPathfinding';//State -1 means the cursor cant interact with anything, nor can the player push buttons to call cursor functions.
        }
    }
    else{
        FillTurnList();
        SortTurnList();
        CurrentTurn = 0;
        //Cursor.CurrentTurn++;
        event_perform(ev_other,ev_user0); //Find Move Range.
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//fix floating point conversions (hopefully if GM actually rounds right)
x = round(x);
y = round(y);

if(State = 'TurnPathfinding'){
    var CurrentCharacter;
    CurrentCharacter = TurnOrder[CurrentTurn];//Who's turn it is
    
    AStar_free(); //Clear the path from memory.
    visible = false; //Cursor becomes invisible.
    State = 'none';
    x = CurrentCharacter.x; //Set cursor to exact player location in case of the path failing.
    y = CurrentCharacter.y;
    with (CurrentCharacter){ //Find Move range and set character to active
        event_perform(ev_other,ev_user0); //Find Move Range.
    }
    //Create battle HUD and pan in
    if(!CurrentCharacter.Hidden){//dont bother with battle controler events if we reveal a unit.
        with(BattleControler){
            HUDPan = 200;//BattleHUD
            LEPan = -200;//LandEffect
            event_perform(ev_other,ev_user1);
            Display = true; //Draw BattleHUD
            HUDPanDirection = 'in'; //Slide Menus in.
            sound_play(MenuPanSound);
        }
    }
}


else if(State = 'TargetPathfinding'){
    AStar_free(); //Clear the path from memory.
    with(TargetSelectionControler){
        PanDirection = 'in';
    }
    sound_play(MenuPanSound);
}

else if(State = 'EndTargetPathfinding'){
    sprite_index = CursorSprite;//set cursor to original size.
    AStar_free(); //Clear the path from memory.
    with(TargetSelectionControler){
        //This event is called when we back out of the controler.
        with(CurrentObject){
            event_perform(ev_other,ev_user8);
        }
        Cursor.State = 'none';
        Cursor.visible = false;
        instance_destroy();
    }
}

else if(State = 'EnemyTargeting'){
    AStar_free(); //Clear the path from memory.
    with(EnemyTargetSelectionControler){
        CreateBattleHUD(Target, "target");
        visible = true;
        PanDirection = 'in';
    }
    sound_play(MenuPanSound);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite(sprite_index,image_index,x,y);

//floating point debug test
//draw_text(x,y,string(round(x)) + " " + string(round(y)));
//draw_text(x,y+ 20,string(x) + " " + string(y));
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
