<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//This is the menu object for (Attack, magic, items, stay)
//How fast the menu animates.
AllowInteraction = false;
image_speed = .0625;

var CurrentCharacter;//The guy who's inventory we're messing with.
CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];

//These are the 4 menu slot sprites (Left and Right are used for yes / no menu)
MenuTopVar = Get_Spell_Stats(CurrentCharacter.Spells[1],CurrentCharacter.SpellLevel[1],'Sprite');
MenuLeftVar = Get_Spell_Stats(CurrentCharacter.Spells[2],CurrentCharacter.SpellLevel[2],'Sprite');
MenuRightVar = Get_Spell_Stats(CurrentCharacter.Spells[3],CurrentCharacter.SpellLevel[3],'Sprite');
MenuBottomVar = Get_Spell_Stats(CurrentCharacter.Spells[4],CurrentCharacter.SpellLevel[4],'Sprite');

//These animate the menu when selected. 0 for not animated, -1 for animated.
MenuAnimTop = 0;
MenuAnimBottom = 0;
MenuAnimLeft = 0;
MenuAnimRight = 0;

//The X and Y pans of the menu (For sliding)
MenuPanX = 0;
MenuPanY = 0;

PanDirection = 'none';

PerformEvent = 'none'; //What event do we perform? This is set when selecting or backing out.
DialogueState = 0;
SpellCastSlot = 1;
SpellCastLevel = CurrentCharacter.SpellLevel[1];
State = 'Selecting Spell';

//Display Spell Range
FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),Get_Spell_Stats(CurrentCharacter.Spells[1],CurrentCharacter.SpellLevel[1],'SpellRange'),Get_Spell_Stats(CurrentCharacter.Spells[1],CurrentCharacter.SpellLevel[1],'SpellLimit'),Get_Spell_Stats(CurrentCharacter.Spells[1],CurrentCharacter.SpellLevel[1],'TargetType'));
FlashAttackTiles();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(PanDirection != 'none'){
//This slides the menu in/out.
    //Panning in
    if(PanDirection = 'up'){
        MenuPanY -= 25;
        if(MenuPanY &lt;= 0){
            MenuPanY = 0;
            PanDirection = 'none';
            AllowInteraction = true;
        }
    }
    
    if(PanDirection = 'left'){
        MenuPanX -= 25;
        if(MenuPanX &lt;= 0){
            MenuPanX = 0;
            PanDirection = 'none';
            AllowInteraction = true;
        }
    }
    
    //Panning out
    if(PanDirection = 'down'){
        MenuPanY += 18;
        if(MenuPanY &gt;= 100){
            MenuPanY = 100;
            PanDirection = 'none';
            event_perform(ev_other,ev_user0);
        }
    }
    
    if(PanDirection = 'right'){
        MenuPanX += 25;
        if(MenuPanX &gt;= 200){
            MenuPanX = 200;
            PanDirection = 'none';
            event_perform(ev_other,ev_user0);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Key Event Listeners
if(AllowInteraction){
    //Select
    if (keyboard_check_pressed(global.SelectButton)){
        if(State = 'Selecting Spell'){
            //We selected 'Top'
            if(MenuAnimTop = -1){
                MenuAnimTop = 1; //Selected spell becomes solid instead of flashing. 
                State = 'Selecting Spell Level';
                sound_play(MenuSelectSound);
            }
            //We selected 'Left'
            else if(MenuAnimLeft = -1){
                MenuAnimLeft = 1; //Selected spell becomes solid instead of flashing. 
                State = 'Selecting Spell Level';
                sound_play(MenuSelectSound);
            }
            //We selected 'Right'
            else if(MenuAnimRight = -1){
                MenuAnimRight = 1; //Selected spell becomes solid instead of flashing. 
                State = 'Selecting Spell Level';
                sound_play(MenuSelectSound);
            }
            //We selected 'Bottom'
            else if(MenuAnimBottom = -1){
                MenuAnimBottom = 1; //Selected spell becomes solid instead of flashing. 
                State = 'Selecting Spell Level';
                sound_play(MenuSelectSound);
            }
        }
        else if(State = 'Selecting Spell Level'){
            var CurrentCharacter;//The guy who's inventory we're messing with.
            CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
            //if we have enough mana to cast the spell
            if(CurrentCharacter.Magic &gt;= (Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'ManaCost'))){
                if(CurrentCharacter.Spells[SpellCastSlot] = 'Egress'){
                    //for now, just restart battle
                    sound_play(SpellCastSound);
                    with(objPlayer){
                        SaveStats(self);
                    }
                    GlobalHealAll();//restore health and mana
                    global.TransitionState = -1;//flagged off demo temp
                    room_goto(TownRoom01);
                    //room_restart();//demo temp
                }
                else{
                    PerformEvent = 'CastSpell';
                    PanDirection = 'right';
                    AllowInteraction = false;
                    sound_play(MenuPanSound);
                }
            }
            else{//we do not have enough mana to cast the spell
                DialogueState = 50;
                AllowInteraction = false;
                event_perform(ev_other,ev_user15);//Display (not enough mana)
            }
        }
    }
    
    //Back
    if (keyboard_check_pressed(global.BackButton)){
        if(State = 'Selecting Spell'){
            sound_play(MenuPanSound);
            PerformEvent = 'BackOut';
            AllowInteraction = false;
            PanDirection = 'down';
        }
        else if(State = 'Selecting Spell Level'){
            var CurrentCharacter;//The guy who's inventory we're messing with.
            CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
            
            State = 'Selecting Spell';
            SpellCastLevel = CurrentCharacter.SpellLevel[SpellCastSlot];
            
            ResetTiles();//Display the updated range for the selected spell and level
            FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellRange'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellLimit'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'TargetType'));
            FlashAttackTiles();
            sound_play(MenuSelectSound);
            
            if(MenuAnimTop = 1){//Fix the menu animation
                MenuAnimTop = -1;
            }
            else if(MenuAnimBottom = 1){
                MenuAnimBottom = -1;
            }
            else if(MenuAnimLeft = 1){
                MenuAnimLeft = -1;
            }
            else if(MenuAnimRight = 1){
                MenuAnimRight = -1;
            }
        }
    }
    
    //Left
    if (keyboard_check_pressed(global.LeftButton)){
        var CurrentCharacter;//The guy who's inventory we're messing with.
        CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
        if(State = 'Selecting Spell'){
            if(CurrentCharacter.Spells[2] != 'none'){//If we have a Spell in this slot,
                //Display Spell Range
                SpellCastSlot = 2;
                SpellCastLevel = CurrentCharacter.SpellLevel[2];
                MenuAnimTop = 0;
                MenuAnimBottom = 0;
                MenuAnimLeft = -1;
                MenuAnimRight = 0;
                sound_play(MenuMoveSound);
                ResetTiles();//Display the updated range for the selected spell and level
                FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellRange'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellLimit'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'TargetType'));
                FlashAttackTiles();
            }
        }
        else if(State = 'Selecting Spell Level'){
            
            //raise cast level.
            if(SpellCastLevel &lt;= 1){//If we go over the max level of this spell,
                SpellCastLevel = CurrentCharacter.SpellLevel[SpellCastSlot];//return to level 1
            }
            else{//otherwise increase the level by 1
                SpellCastLevel -= 1;
            }
            sound_play(MenuMoveSound);
            ResetTiles();//Display the updated range for the selected spell and level
            FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellRange'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellLimit'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'TargetType'));
            FlashAttackTiles();
        }
    }
    
    //Right
    if (keyboard_check_pressed(global.RightButton)){
        var CurrentCharacter;//The guy who's inventory we're messing with.
        CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
        if(State = 'Selecting Spell'){
            if(CurrentCharacter.Spells[3] != 'none'){//If we have a Spell in this slot,
                //Display Spell Range
                SpellCastSlot = 3;
                SpellCastLevel = CurrentCharacter.SpellLevel[3];
                MenuAnimTop = 0;
                MenuAnimBottom = 0;
                MenuAnimLeft = 0;
                MenuAnimRight = -1;
                sound_play(MenuMoveSound);
                ResetTiles();//Display the updated range for the selected spell and level
                FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellRange'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellLimit'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'TargetType'));
                FlashAttackTiles();
            }
        }
        else if(State = 'Selecting Spell Level'){
            
            //raise cast level.
            if(SpellCastLevel &gt;= CurrentCharacter.SpellLevel[SpellCastSlot]){//If we go over the max level of this spell,
                SpellCastLevel = 1;//return to level 1
            }
            else{//otherwise increase the level by 1
                SpellCastLevel += 1;
            }
            sound_play(MenuMoveSound);
            ResetTiles();//Display the updated range for the selected spell and level
            FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellRange'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellLimit'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'TargetType'));
            FlashAttackTiles();
        }
    }
    
    //Up
    if (keyboard_check_pressed(global.UpButton)){
        var CurrentCharacter;//The guy who's inventory we're messing with.
        CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
        if(State = 'Selecting Spell'){
            if(CurrentCharacter.Spells[1] != 'none'){//If we have a Spell in this slot,
                //Display Spell Range
                SpellCastSlot = 1;
                SpellCastLevel = CurrentCharacter.SpellLevel[1];
                MenuAnimTop = -1;
                MenuAnimBottom = 0;
                MenuAnimLeft = 0;
                MenuAnimRight = 0;
                sound_play(MenuMoveSound);
                ResetTiles();//Display the updated range for the selected spell and level
                FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellRange'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellLimit'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'TargetType'));
                FlashAttackTiles();
            }
        }
        else if(State = 'Selecting Spell Level'){
            
            //raise cast level.
            if(SpellCastLevel &gt;= CurrentCharacter.SpellLevel[SpellCastSlot]){//If we go over the max level of this spell,
                SpellCastLevel = 1;//return to level 1
            }
            else{//otherwise increase the level by 1
                SpellCastLevel += 1;
            }
            sound_play(MenuMoveSound);
            ResetTiles();//Display the updated range for the selected spell and level
            FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellRange'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellLimit'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'TargetType'));
            FlashAttackTiles();
        }
    }
    
    //Down
    if (keyboard_check_pressed(global.DownButton)){
        var CurrentCharacter;//The guy who's inventory we're messing with.
        CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
        if(State = 'Selecting Spell'){
            if(CurrentCharacter.Spells[4] != 'none'){//If we have a Spell in this slot,
                //Display Spell Range
                SpellCastSlot = 4;
                SpellCastLevel = CurrentCharacter.SpellLevel[4];
                MenuAnimTop = 0;
                MenuAnimBottom = -1;
                MenuAnimLeft = 0;
                MenuAnimRight = 0;
                sound_play(MenuMoveSound);
                ResetTiles();//Display the updated range for the selected spell and level
                FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellRange'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellLimit'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'TargetType'));
                FlashAttackTiles();
            }
        }
        else if(State = 'Selecting Spell Level'){
            
            //raise cast level.
            if(SpellCastLevel &lt;= 1){//If we go over the max level of this spell,
                SpellCastLevel = CurrentCharacter.SpellLevel[SpellCastSlot];//return to level 1
            }
            else{//otherwise increase the level by 1
                SpellCastLevel -= 1;
            }
            sound_play(MenuMoveSound);
            ResetTiles();//Display the updated range for the selected spell and level
            FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellRange'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'SpellLimit'),Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot],SpellCastLevel,'TargetType'));
            FlashAttackTiles();
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//No Targets in range
if(DialogueState = 0){
    CreateDialogueBasic(0,0,"No targets in range!",self.id,false);
    DialogueState +=1;
}
else if(DialogueState = 1){
    DialogueState +=1;
    sound_play(MenuPanSound);
    PanOutDialogueBasic();
}
else if(DialogueState = 2){
    sound_play(MenuPanSound);
    PerformEvent = 'none';
    PanDirection = 'left';
}


//Not enough Magic
if(DialogueState = 50){
    CreateDialogueBasic(0,0,"Not enough magic!",self.id,false);
    DialogueState +=1;
}
else if(DialogueState = 51){
    DialogueState +=1;
    sound_play(MenuPanSound);
    PanOutDialogueBasic();
}
else if(DialogueState = 52){
    DialogueState = 0;
    AllowInteraction = true;
}


</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="18">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//User8 takes calls from Target Selection Controler
//In this case, we backed out of choosing a target to 'Give' to
PanDirection = 'left'; //Pan back in
sound_play(MenuPanSound);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if we are panning out, what do we do next?
//===============
//Cancel Action==
//===============
if(PerformEvent = 'BackOut'){//Previous Menu (or go back to whatever)
    //destroy this controler and re-create the previous one
    ResetTiles();//Disable the flashing tiles
    Cursor.sprite_index = CursorSprite;//reset cursor sprite
    instance_create(0,0,MainBattleMenuControler);
    with(MainBattleMenuControler){
        MenuAnimLeft= -1;
        sound_play(MenuPanSound);
        PanDirection = 'left';
        MenuPanX = 200;
        MenuPanY = 0;
    }
    instance_destroy();
}

//============
//Spell Cast==
//============
else if(PerformEvent = 'CastSpell'){//Casting a spell
    var CurrentCharacter;//The guy who's inventory we're messing with.
    CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
    if(Cursor.NumberOfTargets = 0){//We have no targets, bring in dialogue controler.
        DialogueState = 0;
        event_perform(ev_other,ev_user15);
    }
    else{//We have targets, so... go get em!
        //Set cursor to correct size when casting spell
        GetCursorSprite(Get_Spell_Stats(CurrentCharacter.Spells[SpellCastSlot], SpellCastLevel, 'Area'));
        instance_create(0,0,TargetSelectionControler);
        with(TargetSelectionControler){
            CurrentObject = MagicBattleMenuControler;//Remember that this controler created it
            Action = 'Magic';
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var CurrentCharacter;//The guy who's inventory we're messing with.
CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];

draw_set_halign(fa_left);
draw_set_font(MenuFont); 
draw_sprite(MenuTopVar,0,view_xview+122+MenuPanX,view_yview+200+MenuPanY);
draw_sprite(MenuLeftVar,0,view_xview+106+MenuPanX,view_yview+212+MenuPanY);
draw_sprite(MenuRightVar,0,view_xview+138+MenuPanX,view_yview+212+MenuPanY);
draw_sprite(MenuBottomVar,0,view_xview+122+MenuPanX,view_yview+224+MenuPanY);
draw_sprite(LandEffectWindowSprite,0,view_xview+160+MenuPanX,view_yview+200+MenuPanY);

//Top Spell Slot
if(MenuAnimTop != 0){
    draw_sprite(ItemFlashSprite,MenuAnimTop,view_xview+122+MenuPanX,view_yview+200+MenuPanY);
    draw_set_halign(fa_left);
    draw_text(view_xview + 170+MenuPanX, view_yview + 197+MenuPanY, string(CurrentCharacter.Spells[1]));
    draw_text(view_xview + 170+MenuPanX, view_yview + 214+MenuPanY, 'MP');
    draw_set_halign(fa_right);
    draw_text(view_xview + 220+MenuPanX, view_yview + 214+MenuPanY, string(Get_Spell_Stats(CurrentCharacter.Spells[1],SpellCastLevel,'ManaCost'))); //Draws spell's mana cost
    
    //Loop Draw "Magic Level Counter thingys" based on spell level;
    var SpellCounter;
    SpellCounter = 0;
    while(SpellCounter &lt; CurrentCharacter.SpellLevel[1]){
    if(SpellCounter &gt;= SpellCastLevel){
        draw_sprite(SpellLevelSprite,1,view_xview+170+(12*SpellCounter)+MenuPanX,view_yview+218+MenuPanY);
    }
    else{
        draw_sprite(SpellLevelSprite,0,view_xview+170+(12*SpellCounter)+MenuPanX,view_yview+218+MenuPanY);
    }
    SpellCounter +=1;
    }
}

//Left Spell Slot
if(MenuAnimLeft != 0){
    draw_sprite(ItemFlashSprite,MenuAnimLeft,view_xview+106+MenuPanX,view_yview+212+MenuPanY);
    draw_set_halign(fa_left);
    draw_text(view_xview + 170+MenuPanX, view_yview + 197+MenuPanY, string(CurrentCharacter.Spells[2]));
    draw_text(view_xview + 170+MenuPanX, view_yview + 214+MenuPanY, 'MP');
    draw_set_halign(fa_right);
    draw_text(view_xview + 220+MenuPanX, view_yview + 214+MenuPanY, string(Get_Spell_Stats(CurrentCharacter.Spells[2],SpellCastLevel,'ManaCost'))); //Draws spell's mana cost
    
    //Loop Draw "Magic Level Counter thingys" based on spell level;
    var SpellCounter;
    SpellCounter = 0;
    while(SpellCounter &lt; CurrentCharacter.SpellLevel[2]){
    if(SpellCounter &gt;= SpellCastLevel){
        draw_sprite(SpellLevelSprite,1,view_xview+170+(12*SpellCounter)+MenuPanX,view_yview+218+MenuPanY);
    }
    else{
        draw_sprite(SpellLevelSprite,0,view_xview+170+(12*SpellCounter)+MenuPanX,view_yview+218+MenuPanY);
    }
    SpellCounter +=1;
    }
}

//Right Spell Slot
if(MenuAnimRight != 0){
    draw_sprite(ItemFlashSprite,MenuAnimRight,view_xview+138+MenuPanX,view_yview+212+MenuPanY);
    draw_set_halign(fa_left);
    draw_text(view_xview + 170+MenuPanX, view_yview + 197+MenuPanY, string(CurrentCharacter.Spells[3]));
    draw_text(view_xview + 170+MenuPanX, view_yview + 214+MenuPanY, 'MP');
    draw_set_halign(fa_right);
    draw_text(view_xview + 220+MenuPanX, view_yview + 214+MenuPanY, string(Get_Spell_Stats(CurrentCharacter.Spells[3],SpellCastLevel,'ManaCost'))); //Draws spell's mana cost
    
    //Loop Draw "Magic Level Counter thingys" based on spell level;
    var SpellCounter;
    SpellCounter = 0;
    while(SpellCounter &lt; CurrentCharacter.SpellLevel[3]){
    if(SpellCounter &gt;= SpellCastLevel){
        draw_sprite(SpellLevelSprite,1,view_xview+170+(12*SpellCounter)+MenuPanX,view_yview+218+MenuPanY);
    }
    else{
        draw_sprite(SpellLevelSprite,0,view_xview+170+(12*SpellCounter)+MenuPanX,view_yview+218+MenuPanY);
    }
    SpellCounter +=1;
    }
}

//Bottom Spell Slot
if(MenuAnimBottom != 0){
    draw_sprite(ItemFlashSprite,MenuAnimBottom,view_xview+122+MenuPanX,view_yview+224+MenuPanY);
    draw_set_halign(fa_left);
    draw_text(view_xview + 170+MenuPanX, view_yview + 197+MenuPanY, string(CurrentCharacter.Spells[4]));
    draw_text(view_xview + 170+MenuPanX, view_yview + 214+MenuPanY, 'MP');
    draw_set_halign(fa_right);
    draw_text(view_xview + 220+MenuPanX, view_yview + 214+MenuPanY, string(Get_Spell_Stats(CurrentCharacter.Spells[4],SpellCastLevel,'ManaCost'))); //Draws spell's mana cost
    
    //Loop Draw "Magic Level Counter thingys" based on spell level;
    var SpellCounter;
    SpellCounter = 0;
    while(SpellCounter &lt; CurrentCharacter.SpellLevel[4]){
    if(SpellCounter &gt;= SpellCastLevel){
        draw_sprite(SpellLevelSprite,1,view_xview+170+(12*SpellCounter)+MenuPanX,view_yview+218+MenuPanY);
    }
    else{
        draw_sprite(SpellLevelSprite,0,view_xview+170+(12*SpellCounter)+MenuPanX,view_yview+218+MenuPanY);
    }
    SpellCounter +=1;
    }
}

if(State = 'Selecting Spell Level'){
    //Flashy red thing when selecting what spell level to cast
    draw_sprite(MagicMenuFlashSprite,-1,view_xview+167+MenuPanX,view_yview+213+MenuPanY);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
