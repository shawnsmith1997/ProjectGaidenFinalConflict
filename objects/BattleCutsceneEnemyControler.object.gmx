<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1001</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>sound_play(battle_cutscene_BGM);

sprite_index = BlankSprite;
image_speed = .25
image_index = -1;
visible = false;

Pan = -64;
State = 'Idle';
PanDirection = 'Start';
HitFlash = 0;
Hit = 0;

xRand = 0;
yRand = 0;

Character = 'none';
Dead = false;
DeathAlpha = 1;

DisplayType = 'none';
DisplayHUD = false;

FaceDirection = 'Normal'; //Left or Right (Normal or Alt)
CallPanScript = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(PanDirection = 'Start'){
    if(Pan &lt; 0){
        Pan += 4;
        if(Pan &gt;= 0){
            Pan = 0;
            PanDirection = 'none';
        }
    }
}
//Pans out to the right (only until it's off screen)
else if(PanDirection = 'Out'){
    if(Pan &gt; -200){
        Pan -= 32;
        if(Pan &lt;= -200){
            Pan = -200;
            PanDirection = 'none';
            if(CallPanScript){
                with(BattleCutsceneControler){//What do we do next?
                    event_perform(ev_other,ev_user1);
                }
            }
            /*else{
                with(BattleCutsceneControler){//What do we do next?
                    SubState = 'CharacterFinishedPanning';
                    event_perform(ev_other,ev_user0);
                }
            }*/
        }
    }
}
//the opposite of above!
else if(PanDirection = 'In'){
    if(Pan &lt; 0){
        Pan += 32;
        if(Pan &gt;= 0){
            Pan = 0;
            PanDirection = 'none';
            if(CallPanScript){
                with(BattleCutsceneControler){//What do we do next?
                    event_perform(ev_other,ev_user1);
                }
            }
        }
    }
}
//panning the entire scene to the right (the player doesnt come with so they pan left)
else if(PanDirection = 'GlobalRight'){
    if(Pan &gt;= -512){
        Pan -= 32;
        if(Pan &lt;= -512){
            Pan = -512;
            PanDirection = 'none';
            if(CallPanScript){
                with(BattleCutsceneControler){//What do we do next?
                    event_perform(ev_other,ev_user1);
                }
            }
        }
    }
}
//panning the entire scene to the left (the player doesnt come with so they pan right)
else if(PanDirection = 'GlobalLeft'){
    if(Pan &lt;= 0){
        Pan += 32;
        if(Pan &gt;= 0){
            Pan = 0;
            PanDirection = 'none';
            if(CallPanScript){
                with(BattleCutsceneControler){//What do we do next?
                    event_perform(ev_other,ev_user1);
                }
            }
        }
    }
}
//Alternate pans (character facing opposite direction)
//Pans out to the right (only until it's off screen)
else if(PanDirection = 'OutAlt'){
    if(Pan &gt; 200){
        Pan += 32;
        if(Pan &gt;= 200){
            Pan = 200;
            PanDirection = 'none';
            if(CallPanScript){
                with(BattleCutsceneControler){//What do we do next?
                    event_perform(ev_other,ev_user1);
                }
            }
            /*else{
                with(BattleCutsceneControler){//What do we do next?
                    SubState = 'CharacterFinishedPanning';
                    event_perform(ev_other,ev_user0);
                }
            }*/
        }
    }
}
//the opposite of above!
else if(PanDirection = 'InAlt'){
    if(Pan &gt; 0){
        Pan -= 32;
        if(Pan &lt;= 0){
            Pan = 0;
            PanDirection = 'none';
            if(CallPanScript){
                with(BattleCutsceneControler){//What do we do next?
                    event_perform(ev_other,ev_user1);
                }
            }
        }
    }
}
//I guess these 2 are the same... Oh well I'll remove them if I dont need them (and if I remember)
//panning the entire scene to the right (the player doesnt come with so they pan left) 
else if(PanDirection = 'GlobalRightAlt'){
    if(Pan &gt;= -512){
        Pan -= 32;
        if(Pan &lt;= -512){
            Pan = -512;
            PanDirection = 'none';
            if(CallPanScript){
                with(BattleCutsceneControler){//What do we do next?
                    event_perform(ev_other,ev_user1);
                }
            }
        }
    }
}
//panning the entire scene to the left (the player doesnt come with so they pan right)
else if(PanDirection = 'GlobalLeftAlt'){
    if(Pan &lt;= 512){
        Pan += 32;
        if(Pan &gt;= 512){
            Pan = 512;
            PanDirection = 'none';
            if(CallPanScript){
                with(BattleCutsceneControler){//What do we do next?
                    event_perform(ev_other,ev_user1);
                }
            }
        }
    }
}



//Note, 'End of animation' event is buggy. Therefore I placed this
//here in the step event since it ALWAYS fires before the draw event.
if (image_index + image_speed &gt;= image_number-1){//test for end of animation
    if(State = 'Attack'){
        State = 'Pause';
        image_speed = 0;//Stop animating
        image_index = image_number -1;//Stop on last frame of animation
        with(BattleCutsceneControler){//What do we do next?
            //State = 'EndAttackSwing';
            event_perform(ev_other,ev_user0);
        }
    }
    else if(State = 'EndAttackAnimation'){
        State = 'none';
        event_perform(ev_other,ev_user0);
        with(BattleCutsceneControler){//What do we do next?
            //State = 'EndAttackPhase';
            event_perform(ev_other,ev_user0);
        }
    }
    else if(State = 'Block'){
        State = 'Pause';
        image_speed = 0;//Stop animating
        image_index = image_number -1;//Stop on last frame of animation
        with(BattleCutsceneControler){//What do we do next?
            event_perform(ev_other,ev_user0);
        }
    }
    else if(State = 'EndBlockAnimation'){ 
        State = 'none';
        event_perform(ev_other,ev_user0);
        with(BattleCutsceneControler){//What do we do next?
            event_perform(ev_other,ev_user0);
        }
    }
    else if(State = 'SpellCast'){
        State = 'Pause';
        image_speed = 0;//Stop animating
        image_index = image_number -1;//Stop on last frame of animation
        with(BattleCutsceneControler){//What do we do next?
            event_perform(ev_other,ev_user0);
        }
    }
    else if(State = 'EndSpellAnimation'){
        State = 'none';
        event_perform(ev_other,ev_user0);
        with(BattleCutsceneControler){//What do we do next?
            //State = 'EndAttackPhase';
            event_perform(ev_other,ev_user0);
        }
    }
    else if(State = 'ItemUse'){
        State = 'Pause';
        image_speed = 0;//Stop animating
        image_index = image_number -1;//Stop on last frame of animation
        with(BattleCutsceneControler){//What do we do next?
            //State = 'EndAttackSwing';
            event_perform(ev_other,ev_user0);
        }
    }
}


if(State = 'Hit'){//Takes care of the hit animation for the character
    if(Hit &gt;= 0){
        xRand = round(random_range(-7,7));
        yRand = round(random_range(-7,7));
        Hit -= .5;
        if(Hit &lt;= 0){
            Hit = 0;
            State = 'none';
            with(BattleCutsceneControler){
                event_perform(ev_other,ev_user0);
            }
        }
    }
}

if(Dead){
    if(DeathAlpha &gt; 0){
        DeathAlpha -= .04;
        if(DeathAlpha &lt;= 0){
            DeathAlpha = 0;
        }
    }
}











































//Note, 'End of animation' event is buggy. Therefore I placed this
//here in the step event since it ALWAYS fires before the draw event.
if (image_index + image_speed &gt;= image_number-1){//test for end of animation
    if(State = 'Attack'){
        State = 'none';
        image_speed = 0;//Stop animating
        image_index = image_number -1;//Stop on last frame of animation
        with(BattleCutsceneControler){//What do we do next?
            //State = 'EndAttackSwing';
            event_perform(ev_other,ev_user0);
        }
    }
    else if(State = 'EndAttackAnimation'){
        State = 'none';
        event_perform(ev_other,ev_user0);
        with(BattleCutsceneControler){//What do we do next?
            //State = 'EndAttackPhase';
            event_perform(ev_other,ev_user0);
        }
    }
    else if(State = 'Block'){
        State = 'none';
        image_speed = 0;//Stop animating
        image_index = image_number -1;//Stop on last frame of animation
        with(BattleCutsceneControler){//What do we do next?
            event_perform(ev_other,ev_user0);
        }
    }
    else if(State = 'EndBlockAnimation'){ 
        State = 'none';
        event_perform(ev_other,ev_user0);
        with(BattleCutsceneControler){//What do we do next?
            event_perform(ev_other,ev_user0);
        }
    }
    else if(State = 'SpellCast'){
        State = 'none';
        image_speed = 0;//Stop animating
        image_index = image_number -1;//Stop on last frame of animation
        with(BattleCutsceneControler){//What do we do next?
            event_perform(ev_other,ev_user0);
        }
    }
}

    

if(State = 'Hit'){//Takes care of the hit animation for the character
    if(Hit &gt;= 0){
        xRand = round(random_range(-7,7));
        yRand = round(random_range(-7,7));
        Hit -= .5;
        if(Hit &lt;= 0){
            Hit = 0;
            State = 'none';
            with(BattleCutsceneControler){
                event_perform(ev_other,ev_user0);
            }
        }
    }
}

if(Dead){
    if(DeathAlpha &gt; 0){
        DeathAlpha -= .04;
        if(DeathAlpha &lt;= 0){
            DeathAlpha = 0;
        }
    }
}










</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(DisplayType = 'Main'){
    CreateBattleHUD(Character, "main");
}
else if(DisplayType = 'Target'){
    CreateBattleHUD(Character, "target");
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//takes care of performing the correct animation
if(State = 'Attack'){
    sprite_index = Get_Battle_Cutscene_Character_Sprite(Character.ID, 'Attack');
    image_speed = Get_Battle_Cutscene_Anim_Speed(Character.ID, image_number);
    image_index = 0;
}
else if(State = 'EndAttackAnimation'){
    sprite_index = Get_Battle_Cutscene_Character_Sprite(Character.ID, 'AttackEnd');
    image_index = 0;
    image_speed = Get_Battle_Cutscene_Anim_Speed(Character.ID, image_number);
}
else if(State = 'Block'){
    sprite_index = Get_Battle_Cutscene_Character_Sprite(Character.ID, 'Block');
    image_speed = Get_Battle_Cutscene_Anim_Speed(Character.ID, image_number);
    image_index = 0;
}
else if(State = 'EndBlockAnimation'){
    sprite_index = Get_Battle_Cutscene_Character_Sprite(Character.ID, 'BlockEnd');
    image_speed = Get_Battle_Cutscene_Anim_Speed(Character.ID, image_number);
    image_index = 0;
}
else if(State = 'SpellCast'){
    sprite_index = Get_Battle_Cutscene_Character_Sprite(Character.ID, 'SpellCast');
    image_speed = Get_Battle_Cutscene_Anim_Speed(Character.ID, image_number);
    image_index = 0;
}
else{//just play idle animation
    sprite_index = Get_Battle_Cutscene_Character_Sprite(Character.ID, 'Idle');
    image_speed = Get_Battle_Cutscene_Anim_Speed(Character.ID, image_number);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(State = 'Hit'){//being hit we do something different
    if(HitFlash = 0){//Flash target white for the first frame of hit animation;
        d3d_set_fog(true,c_white,0,0);//Enable fog making object flash white
        draw_sprite(sprite_index,image_index,view_xview+57+Pan+xRand,view_yview+170+yRand);//draw sprite
        d3d_set_fog(false,c_white,0,0);//Disable fog
        HitFlash = 1;
    }
    else{
        draw_sprite(sprite_index,image_index,view_xview+57+Pan+xRand,view_yview+170+yRand);//draw sprite
    }
}
else{//otherwise just draw the normal sprite;
    draw_sprite_ext(sprite_index,image_index,view_xview+57+Pan,view_yview+170,1,1,0,draw_get_color(),DeathAlpha);
}

if(DisplayHUD){
    if(DisplayType = 'Main'){
        if (!surface_exists(MainBattleHUDSurface)){
            CreateBattleHUD(Character, "main");
        }
        draw_surface(MainBattleHUDSurface,view_xview + 5, view_yview + 190);//Draw player battle HUD
    }
    else if(DisplayType = 'Target'){
        if (!surface_exists(TargetBattleHUDSurface)){
            CreateBattleHUD(Character, "target");
        }
        draw_surface(TargetBattleHUDSurface,view_xview + 5, view_yview + 190);//Draw player battle HUD
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
