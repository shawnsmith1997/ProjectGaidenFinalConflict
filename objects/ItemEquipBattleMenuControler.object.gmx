<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//How fast the menu animates.
AllowInteraction = false;
image_speed = .0625;

var CurrentCharacter;//The guy who's inventory we're messing with.
CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];

EquippableItems[0] = 0;
Get_Battle_Equippable_Items(CurrentCharacter,self.id);//Gets a list of equippable weapons and stores it in the above array.

ResetTiles();//Display attack range
FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),CurrentCharacter.AttackRange + Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedWeapon], 'AttackRange')+Get_Item_Stats(CurrentCharacter.Items[EquippableItems[1]], 'AttackRange'),CurrentCharacter.AttackLimit + Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedWeapon], 'AttackLimit')+Get_Item_Stats(CurrentCharacter.Items[EquippableItems[1]], 'AttackLimit'),2);
FlashAttackTiles();

//These are the 4 menu slot sprites (Left and Right are used for yes / no menu)
MenuTopVar = Get_Item_Stats(CurrentCharacter.Items[EquippableItems[1]],'Sprite');
MenuLeftVar = Get_Item_Stats(CurrentCharacter.Items[EquippableItems[2]],'Sprite');
MenuRightVar = Get_Item_Stats(CurrentCharacter.Items[EquippableItems[3]],'Sprite');
MenuBottomVar = RemoveItemSprite;

//These animate the menu when selected. 0 for not animated, -1 for animated.
MenuAnimTop = 0;
MenuAnimBottom = 0;
MenuAnimLeft = 0;
MenuAnimRight = 0;

//The X and Y pans of the menu (For sliding)
MenuPanX = 0;
MenuPanY = 0;

PanDirection = 'none';
PerformEvent = 'none'; //What event do we perform? This is set when selecting or backing out.

SelectedItem = 1;//Makes working with the stat display much easier
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(PanDirection != 'none'){
//This slides the menu in/out.
    //Panning in
    if(PanDirection = 'up'){
        MenuPanY -= 25;
        if(MenuPanY &lt;= 0){
            MenuPanY = 0;
            PanDirection = 'none';
            
            var CurrentCharacter;//The guy who's inventory we're messing with.
            CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
            if(!instance_exists(EquipStatsBattleWindowControler)){//if the stat display doesnt exist,
                //Provide it with the breadth of life
                instance_create(0,0,EquipStatsBattleWindowControler);
                with(EquipStatsBattleWindowControler){
                    PanDirection = 'in';
                    CurrentObject = ItemEquipBattleMenuControler;
                    State = 'Items';
                    sound_play(MenuPanSound);
                }
            }
            else{
                AllowInteraction = true;
            }
        }
    }
    
    if(PanDirection = 'left'){
        MenuPanX -= 25;
        if(MenuPanX &lt;= 0){
            MenuPanX = 0;
            PanDirection = 'none';
            AllowInteraction = true;
        }
    }
    
    //Panning out
    if(PanDirection = 'down'){
        MenuPanY += 18;
        if(MenuPanY &gt;= 100){
            MenuPanY = 100;
            PanDirection = 'none';
            event_perform(ev_other,ev_user0);
        }
    }
    
    if(PanDirection = 'right'){
        MenuPanX += 25;
        if(MenuPanX &gt;= 200){
            MenuPanX = 200;
            PanDirection = 'none';
            event_perform(ev_other,ev_user0);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Key Event Listeners
if(AllowInteraction){
    //Select
    if (keyboard_check_pressed(global.SelectButton)){
        var CurrentCharacter;//The guy who's inventory we're messing with.
        CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
        
        //Update the character's equipped weapon
         var lastItem = CurrentCharacter.EquippedItem;
        CurrentCharacter.EquippedItem = EquippableItems[SelectedItem];
        //Update the character's equipped weapon

        AllowInteraction = false;
        if(Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedItem] ,'Cursed') = 1 and CurrentCharacter.Cursed = 0){
           CurrentCharacter.EquippedItem = EquippableItems[SelectedItem];
           CurrentCharacter.Cursed = 1;
           global.Cursed[CurrentCharacter.ID] = true;
           CreateDialogueBasic(0,0,CurrentCharacter.Name + " has been cursed!",ItemEquipBattleMenuControler,true);
           sound_play(CurseSound);
           EnableDialogueBasic(true);
           PanDirection = 'right';
           sound_play(MenuPanSound);
           //PerformEvent = 'Selected Item'
           ResetTiles();
        }
        else{
            if(CurrentCharacter.Cursed = 1 and (Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedItem] ,'Cursed') = 0)){
               CreateDialogueBasic(0,0,CurrentCharacter.Name + " likes the item too much!",ItemEquipBattleMenuControler,true);
               CurrentCharacter.EquippedItem = lastItem;
               sound_play(CurseSound);
               EnableDialogueBasic(true);
               PanDirection = 'right';
               sound_play(MenuPanSound);
               //PerformEvent = 'Selected Item'
               ResetTiles();
            }
            else{
            CurrentCharacter.EquippedItem = EquippableItems[SelectedItem];
            //we selected an item to equip
            PanDirection = 'right';
            sound_play(MenuPanSound);
            PerformEvent = 'Selected Item'
            ResetTiles();
            }
        }
        
        
        /*if (Get_Item_Stats(EquippableItems[SelectedItem],'Cursed') = 1){
            CurrentCharacter.Cursed = 1;
            CreateDialogueBasic(0,0,CurrentCharacter.Name + " has been cursed!",WeaponEquipBattleMenuControler,true);
            sound_play(CurseSound);
            EnableDialogueBasic(true);
        }
        CurrentCharacter.EquippedItem = EquippableItems[SelectedItem];
        
        //we selected an item to equip
        PanDirection = 'right';
        sound_play(MenuPanSound);
        PerformEvent = 'Selected Item';
        AllowInteraction = false;
        ResetTiles();*/
    }
    
    //Back
    if (keyboard_check_pressed(global.BackButton)){
        var CurrentCharacter;//The guy who's inventory we're messing with.
        CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
        
        ResetTiles();//disable tile flash
        if(Has_Equippable_Weapon_Battle(CurrentCharacter)){//if we back out to weapons
            sound_play(MenuPanSound);
            PanDirection = 'down';
            PerformEvent = 'BackOut';
        }
        else {//else, no weapons, back out to item menu
            with(EquipStatsBattleWindowControler){
                PanDirection = 'out';
                sound_play(MenuPanSound);
            }
        }
    }
    
    //Left
    if (keyboard_check_pressed(global.LeftButton)){
        var CurrentCharacter;//The guy who's inventory we're messing with.
        CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
        
        if(CurrentCharacter.Items[EquippableItems[2]] != 0){
            SelectedItem = 2;
            MenuAnimTop = 0;
            MenuAnimBottom = 0;
            MenuAnimLeft = -1;
            MenuAnimRight = 0;
            sound_play(MenuMoveSound);
            ResetTiles();
            FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),CurrentCharacter.AttackRange + Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedWeapon], 'AttackRange')+Get_Item_Stats(CurrentCharacter.Items[EquippableItems[2]], 'AttackRange'),CurrentCharacter.AttackLimit + Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedWeapon], 'AttackLimit')+Get_Item_Stats(CurrentCharacter.Items[EquippableItems[2]], 'AttackLimit'),2);
            FlashAttackTiles();
        }
    }
    
    //Right
    if (keyboard_check_pressed(global.RightButton)){
        var CurrentCharacter;//The guy who's inventory we're messing with.
        CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
        
        if(CurrentCharacter.Items[EquippableItems[3]] != 0){
            SelectedItem = 3;
            MenuAnimTop = 0;
            MenuAnimBottom = 0;
            MenuAnimLeft = 0;
            MenuAnimRight = -1;
            sound_play(MenuMoveSound);
            ResetTiles();
            FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),CurrentCharacter.AttackRange + Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedWeapon], 'AttackRange')+Get_Item_Stats(CurrentCharacter.Items[EquippableItems[3]], 'AttackRange'),CurrentCharacter.AttackLimit + Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedWeapon], 'AttackLimit')+Get_Item_Stats(CurrentCharacter.Items[EquippableItems[3]], 'AttackLimit'),2);
            FlashAttackTiles();
        }
    }
    
    //Up
    if (keyboard_check_pressed(global.UpButton)){
        var CurrentCharacter;//The guy who's inventory we're messing with.
        CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
        
        if(CurrentCharacter.Items[EquippableItems[1]] != 0){
            SelectedItem = 1;
            MenuAnimTop = -1;
            MenuAnimBottom = 0;
            MenuAnimLeft = 0;
            MenuAnimRight = 0;
            sound_play(MenuMoveSound);
            ResetTiles();
            FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),CurrentCharacter.AttackRange + Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedWeapon], 'AttackRange')+Get_Item_Stats(CurrentCharacter.Items[EquippableItems[1]], 'AttackRange'),CurrentCharacter.AttackLimit + Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedWeapon], 'AttackLimit')+Get_Item_Stats(CurrentCharacter.Items[EquippableItems[1]], 'AttackLimit'),2);
            FlashAttackTiles();
        }
    }
    
    //Down
    if (keyboard_check_pressed(global.DownButton)){
        var CurrentCharacter;//The guy who's inventory we're messing with.
        CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
        //We can move down at any time since down is 'remove item'
        SelectedItem = 0;
        MenuAnimTop = 0;
        MenuAnimBottom = -1;
        MenuAnimLeft = 0;
        MenuAnimRight = 0;
        sound_play(MenuMoveSound);
        ResetTiles();
        FindAttackRange(instance_position(round(CurrentCharacter.x), round(CurrentCharacter.y), objCell),CurrentCharacter.AttackRange + Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedWeapon], 'AttackRange'),CurrentCharacter.AttackLimit + Get_Item_Stats(CurrentCharacter.Items[CurrentCharacter.EquippedWeapon], 'AttackLimit'),2);
        FlashAttackTiles();
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="25">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>        PanDirection = 'right';
        sound_play(MenuPanSound);
        PerformEvent = 'Selected Item'
        AllowInteraction = false;
        PanOutDialogueBasic();
        ResetTiles();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//if we are panning out, what do we do next?
//===============
//Cancel Action==
//===============
if(PerformEvent = 'BackOut'){//Previous Menu (or go back to whatever)
    //destroy this controler and re-create the previous one
    //ResetTiles();//Disable the flashing tiles
    var CurrentCharacter;//The guy who's inventory we're messing with.
    CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];
    if(Has_Equippable_Weapon_Battle(CurrentCharacter)){//if we back out to weapons
        instance_create(0,0,WeaponEquipBattleMenuControler);
        with(WeaponEquipBattleMenuControler){
            MenuAnimTop = -1;
            sound_play(MenuPanSound);
            PanDirection = 'left';
            MenuPanX = 200;
            MenuPanY = 0;
        }
        EquipStatsBattleWindowControler.State = 'Weapons';
        instance_destroy();
    }
    else{//else back out to item menu
        instance_create(0,0,ItemBattleMenuControler);
        with(ItemBattleMenuControler){
            MenuAnimRight = -1;
            sound_play(MenuPanSound);
            PanDirection = 'left';
            MenuPanX = 200;
            MenuPanY = 0;
        }
        instance_destroy();
    }
}
//===============
//Select Action==
//===============
//testfor equippable items
if(PerformEvent = 'Selected Item'){
    with(EquipStatsBattleWindowControler){
            PanDirection = 'out';
            sound_play(MenuPanSound);
        }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var CurrentCharacter;//The guy who's inventory we're messing with.
CurrentCharacter = Cursor.TurnOrder[Cursor.CurrentTurn];

//Draws the menu
draw_set_font(MenuFont); 
draw_set_color(c_white);
draw_set_halign(fa_left);
draw_sprite(MenuTopVar,MenuAnimTop,view_xview+122+MenuPanX,view_yview+200+MenuPanY);
draw_sprite(MenuLeftVar,MenuAnimLeft,view_xview+106+MenuPanX,view_yview+212+MenuPanY);
draw_sprite(MenuRightVar,MenuAnimRight,view_xview+138+MenuPanX,view_yview+212+MenuPanY);
draw_sprite(MenuBottomVar,MenuAnimBottom,view_xview+122+MenuPanX,view_yview+224+MenuPanY);
draw_sprite(ItemMenuNameSprite,0,view_xview+160+MenuPanX,view_yview+200+MenuPanY);
    
if(MenuAnimTop = -1){//if we currently have the top slot selected
    draw_sprite(ItemFlashSprite,MenuAnimTop,view_xview+122+MenuPanX,view_yview+200+MenuPanY);//Flash selection over Top slot
    draw_text(view_xview + 170+MenuPanX, view_yview + 197+MenuPanY, string(Get_Item_Stats(CurrentCharacter.Items[EquippableItems[1]],'Name')));//print out name part 1
    draw_text(view_xview + 170+MenuPanX, view_yview + 205+MenuPanY, string(Get_Item_Stats(CurrentCharacter.Items[EquippableItems[1]],'Name2')));//print out name part 2
    //Is it equippped?
    if((CurrentCharacter.EquippedWeapon = EquippableItems[SelectedItem])||(CurrentCharacter.EquippedItem = EquippableItems[SelectedItem])){
        draw_set_color(c_orange);
        draw_text(view_xview + 170+MenuPanX, view_yview + 213+MenuPanY, 'Equipped'); //Draws 'Equipped' if the item is equipped
        draw_set_color(c_white);
    }
}
else if(MenuAnimLeft = -1){//if we currently have the left slot selected
    draw_sprite(ItemFlashSprite,MenuAnimLeft,view_xview+106+MenuPanX,view_yview+212+MenuPanY);//Flash selection over Left slot
    draw_text(view_xview + 170+MenuPanX, view_yview + 197+MenuPanY, string(Get_Item_Stats(CurrentCharacter.Items[EquippableItems[2]],'Name')));//print out name part 1
    draw_text(view_xview + 170+MenuPanX, view_yview + 205+MenuPanY, string(Get_Item_Stats(CurrentCharacter.Items[EquippableItems[2]],'Name2')));//print out name part 2
    //Is it equippped?
    if((CurrentCharacter.EquippedWeapon = EquippableItems[SelectedItem])||(CurrentCharacter.EquippedItem = EquippableItems[SelectedItem])){
        draw_set_color(c_orange);
        draw_text(view_xview + 170+MenuPanX, view_yview + 213+MenuPanY, 'Equipped'); //Draws 'Equipped' if the item is equipped
        draw_set_color(c_white);
    }
}
else if(MenuAnimRight = -1){//if we currently have the right slot selected
    draw_sprite(ItemFlashSprite,MenuAnimRight,view_xview+138+MenuPanX,view_yview+212+MenuPanY);//Flash selection over right slot
    draw_text(view_xview + 170+MenuPanX, view_yview + 197+MenuPanY, string(Get_Item_Stats(CurrentCharacter.Items[EquippableItems[3]],'Name')));//print out name part 1
    draw_text(view_xview + 170+MenuPanX, view_yview + 205+MenuPanY, string(Get_Item_Stats(CurrentCharacter.Items[EquippableItems[3]],'Name2')));//print out name part 2
    //Is it equippped?
    if((CurrentCharacter.EquippedWeapon = EquippableItems[SelectedItem])||(CurrentCharacter.EquippedItem = EquippableItems[SelectedItem])){
        draw_set_color(c_orange);
        draw_text(view_xview + 170+MenuPanX, view_yview + 213+MenuPanY, 'Equipped'); //Draws 'Equipped' if the item is equipped
        draw_set_color(c_white);
    }
}

//To be changed to 'remove'
else if(MenuAnimBottom = -1){//if we currently have the bottom slot selected
    draw_sprite(ItemFlashSprite,MenuAnimBottom,view_xview+122+MenuPanX,view_yview+224+MenuPanY);//Flash selection over bottom slot
    draw_set_color(c_orange);
    draw_text(view_xview + 170+MenuPanX, view_yview + 197+MenuPanY, 'Remove');
    draw_set_color(c_white);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
