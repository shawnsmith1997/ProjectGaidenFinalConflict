<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>DemonStatueSprite</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>objEnemy</parentName>
  <maskName>OverworldCharacterMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>ID = 1052;
Name = 'Demon Statue';
Class = '';
Level = 35;
Health = 42;
MaxHealth = 42;
Magic = 0;
MaxMagic = 0;
Attack = 50;
Defense = 42;
Agility = 20;
MoveRange = 0;
AttackRange = 0;
Experience = 0;
MovementType = 'animal';
BonusTurns = 0;
AttackLimit = 0;
Kills = 0;
Defeats = 0;
AttackArea = 1;
Gold = 1000;

Spells[1] = 'none';
Spells[2] = 'none';
Spells[3] = 'none';
Spells[4] = 'none';

SpellLevel[1] = 0;
SpellLevel[2] = 0;
SpellLevel[3] = 0;
SpellLevel[4] = 0;

Items[1] = 0;
Items[2] = 0;
Items[3] = 0;
Items[4] = 0;

EquippedWeapon = 0;
EquippedItem = 0;

//if(!variable_local_exists("SubID")){
    SubID = 1;
//}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
This is the main prism flower function.
Similar to attack, but it picks the best direction to
fire its shot.
*/

var Character, MaxThreat, Tile, ThreatType, AIDone;// ThreatDirection;
Character = id;//Guy doing the attacking
//ThreatType = argument1;//which threat function to look at
//AIDone = argument2;//are we already performing an action? if so, this script does nothing
MaxThreat = 0;
Tile = noone;

//if(!AIDone){//if we didnt already trigger an AI task
    with(objCell){
        if(Reachable){
            //find attack range
            //show_message("testing tile");
            if((instance_position(x,y,objGuy) = noone)||((x = round(Character.x))&amp;&amp;(y = round(Character.y)))){//If the tile is empty or if occupied by current character
                //Down Range // if(Can shoot this direction)
                FindPrismFlowerDownRange(self.id,Character,3);//FindPrismFlowerDownRange(self.id,Character,1);
                if(Cursor.NumberOfTargets &gt; 0){
                    //loop through targets and figure out which is the best target
                    var Index, Threat;
                    Index = 0;
                    Threat = 0;
                    while(Index &lt; Cursor.NumberOfTargets){
                        Threat += CalculateThreat(Character,Cursor.AttackList[Index]); //CalculateThreat(Character,instance_position(Cursor.AttackList[Index].x,Cursor.AttackList[Index].y,objCell));
                        Index += 1;
                    }
                    if(Threat &gt; MaxThreat){
                        MaxThreat = Threat;
                        Tile = self.id;
                        Character.FireDirection = 'Down';
                    }
                }
                else{
                    AI_DoNothing(Character);
                }
                }
            }
        }
   // }
    if(Tile != noone){//We can attack this turn if there is a target
        Character.CurrentTarget = Tile;
        Character.Action = 'Attack';
        //show_message("found tile");
        AI_MoveToPoint(Character, Tile);
        return true;//AI Successful
    }
    else{
        return false;//AI failed (no targets in range)
    }

return true;//AI was already done



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (direction = 0){
sprite_index = DemonStatueSprite;
}
else if (direction = 90){
sprite_index = DemonStatueSprite;
}
else if (direction = 180){
sprite_index = DemonStatueSprite;
}
else if (direction = 270){
sprite_index = DemonStatueSprite;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Active = false;//Prevent character from being able to move.
    image_speed = .0625;
    Cursor.x = x;//otherwise, crazy game breaking things
    Cursor.y = y;//are bound to happen
    global.CursorPathfinding = true;
    if(CurrentTarget != noone){//We are targeting a character
        if(Action = 'Attack'){
            State = 'none';
            Action = 'none';
            AStar_free();
            ResetTiles();
            //FindAttackRange(instance_position(x,y,objCell), Get_Battle_Stat_Total(self,'AttackRange'), Get_Battle_Stat_Total(self,'AttackLimit'), Faction,'Enemies','Attack');//targets dont matter since we arent interested in the list
            if(FireDirection = 'Down'){
                FindPrismFlowerDownRange(instance_position(x,y,objCell),self.id,3);//FindPrismFlowerDownRange(instance_position(x,y,objCell),self.id,1);
            
            FlashAttackTiles();
            
            var Index, Threat, MaxThreat;
            Index = 0;
            MaxThreat = 0;
            while(Index &lt; Cursor.NumberOfTargets){
                Threat = CalculateThreat(id,Cursor.AttackList[Index]);//CalculateThreat(self.id,instance_position(x, y, objCell),instance_position(Cursor.AttackList[Index].x,Cursor.AttackList[Index].y,objCell));
                if(Threat &gt; MaxThreat){
                    MaxThreat = Threat;
                    CurrentTarget = Cursor.AttackList[Index];
                }
                Index += 1;
            }
            //event_perform(ev_other,ev_user3);//face character in direction of target
            //direction = LookAtTarget(x,y,CurrentTarget.x,CurrentTarget.y);
            GetCursorSprite(Get_Battle_Stat_Total(self,'AttackArea'));
            instance_create(0,0,EnemyTargetSelectionControler);
            EnemyTargetSelectionControler.Character = self.id;
            EnemyTargetSelectionControler.Target = CurrentTarget;
            EnemyTargetSelectionControler.Action = 'LaserEye';
            with(Cursor){//Pathfind with the cursor to the target
                visible = true;
                State = 'EnemyTargeting';
                AStar_init(global.RoomCellWidth,global.RoomCellHeight,24,24,0,0,1,0,-2,-2,0,0);
                myPath = -1;
            }
            Cursor.myPath = AStar_findPath(Cursor.x,Cursor.y,CurrentTarget.x,CurrentTarget.y,0);
            with(Cursor){  
                //State = 'Pathfinding';
                path_start(myPath,3,0,0);//speed 5?
                xstart = x;
                ystart = y;
            }
            CurrentTarget = noone;
        }
    }
    else{//Otherwise we just end 
        AStar_free();
        direction = 270;
        State = 'none';
        Active = false;
        image_index = BattleControler.image_index; //keeps every character marching in sync
        ResetTiles();
        with(BattleControler){
            State = 'Stay';
            LEPanDirection = 'out';
            sound_play(MenuPanSound);
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
