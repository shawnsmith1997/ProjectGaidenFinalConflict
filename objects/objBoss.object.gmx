<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>LandEffectForest</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>objGuy</parentName>
  <maskName>OverworldCharacterMask</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>    // Variables to assist actual grid movement
gridSize = 24;    // Set as power of 2 (1,2,4,8,16,32...)
isMoving = false; // True when player walking on grid
moveTimer = 0;    // Set to gridSize when move start
moveSpeed = 2.4;    // Set as Power of 2
speedX = 0;       // horizontal walking speed
speedY = 0;       // vertical walking speed

    // Keep track of direction
direction = 270; 

    // Helpful for setting state after moving
justStoppedMoving = true;


Active = false;
Menu = false;
//HadTurn = false;
State = 'none';
Temp = 0;
IsTurn = false;
IsAttacking = false;
CanReachPlayer = false;
GuyType = 'boss';

//For enemies, this only changes when AI is updated.
//Mainly for wandering.
xOrig = x;
yOrig = y;

//For determining where to move to
TargetArray[0] = 0;
NumberOfTargets = 0;

CurrentTarget = noone;
Action = 'none';
SpellCast = 0;
SpellCastLevel = 0;
OverwriteDeathEvent = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!OverwriteDeathEvent){//dont fire event if the battle never plays
    //in case of death, fill its vacancy in the turn order with 'noone'
    FillDeathVoid(self.id);
    EnemyDeathScript();
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="6">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//performs action based on AI
GlobalEnemyAI(self.id);
//Demo_AI_Script01(self.id);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Death Script
if (DeathState = 0){
direction = 180;

DeathState = 2;
alarm[4] = 2;
}
else if (DeathState = 2){
direction = 90;

DeathState = 3;
alarm[4] = 2;
}
else if (DeathState = 3){
direction = 0;

DeathState = 4;
alarm[4] = 2;
}
else if (DeathState = 4){
direction = 270;

DeathState = 5;
alarm[4] = 2;
}




else if (DeathState = 5){
direction = 180;

DeathState = 6;
alarm[4] = 2;
}
else if (DeathState = 6){
direction = 90;

DeathState = 7;
alarm[4] = 2;
}
else if (DeathState = 7){
direction = 0;

DeathState = 8;
alarm[4] = 2;
}
else if (DeathState = 8){
direction = 270;

DeathState = 9;
alarm[4] = 2;
}







else if (DeathState = 9){
direction = 180;

DeathState = 10;
alarm[4] = 2;
}
else if (DeathState = 10){
direction = 90;

DeathState = 11;
alarm[4] = 2;
}
else if (DeathState = 11){
direction = 0;

DeathState = 12;
alarm[4] = 2;
}
else if (DeathState = 12){
direction = 270;

DeathState = 13;
alarm[4] = 2;
}

else if(DeathState = 13){
    DeathState = 0;
    Hidden = false;
    BattleControler.State = 'RevealHidden';
    with(BattleControler){
        event_perform(ev_other,ev_user15);
    }
}











</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Death Script
if (DeathState = 0){
direction = 180;

DeathState = 2;
alarm[3] = 2;
}
else if (DeathState = 2){
direction = 90;

DeathState = 3;
alarm[3] = 2;
}
else if (DeathState = 3){
direction = 0;

DeathState = 4;
alarm[3] = 2;
}
else if (DeathState = 4){
direction = 270;

DeathState = 5;
alarm[3] = 2;
}




else if (DeathState = 5){
direction = 180;

DeathState = 6;
alarm[3] = 2;
}
else if (DeathState = 6){
direction = 90;

DeathState = 7;
alarm[3] = 2;
}
else if (DeathState = 7){
direction = 0;

DeathState = 8;
alarm[3] = 2;
}
else if (DeathState = 8){
direction = 270;

DeathState = 9;
alarm[3] = 2;
}







else if (DeathState = 9){
direction = 180;

DeathState = 10;
alarm[3] = 2;
}
else if (DeathState = 10){
direction = 90;

DeathState = 11;
alarm[3] = 2;
}
else if (DeathState = 11){
direction = 0;

DeathState = 12;
alarm[3] = 2;
}
else if (DeathState = 12){
direction = 270;

DeathState = 13;
alarm[3] = 2;
}

else if(DeathState = 13){
instance_create(x,y,BoomObj);
instance_destroy();

}











</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (State = 'Pathfinding'){ //Character is walking to new location
    if (Cursor.x &lt; x){
        direction = 0;//Going Right
    }
    if (Cursor.x &gt; x){
        direction = 180;//Going Left
    }
    if (Cursor.y &lt; y){
        direction = 270;//Going down
    }
    if (Cursor.y &gt; y){
        direction = 90;//Going Up
    }
    //avoids speed errors and a few other issues
    x= round(x);
    y= round(y);
    Cursor.x = x;
    Cursor.y = y;
    
    Temp -= 3;//Play StepSound every tile it walks
    if (Temp &lt;= 0)
    {
        sound_play(StepSound);
        Temp = 24;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="13">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Facing up / down takes precidence over left / right.
//In case of a tie

var xDifference, yDifference, xDirection, yDirection;

//Calculate the difference between the two character's coordinates
xDifference = x - CurrentTarget.x;
yDifference = y - CurrentTarget.y;

//Calculate X and Y direction
//X Direction
if(xDifference &gt; 0){
    xDirection = 180 //Left
}
else if(xDifference &lt; 0){
    xDirection = 0 //right
}
else{//Same x coordinate
    xDirection = 270 //down
}
//Y Direction
if(yDifference &gt; 0){
    yDirection = 90 //up
}
else if(yDifference &lt; 0){
    yDirection = 270 //down
}
else{//Same y coordinate
    yDirection = 270 //down
}

if(abs(yDifference) &gt;= abs(xDifference)){
    direction = yDirection;
}
else{
    direction = xDirection;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
if(Hidden){
    alarm[4] = 1;
    visible = true;
}
else{
    depth = -11;
    FindMovementRange( instance_position( x, y, objCell ), self.id);//find the character's movement range
    FlashMoveTiles();//Display tile flashes
    alarm[6] = 40;//figure out AI stuff after a delay 
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>Cursor.x = round(x);//Lock cursor to enemy's final location to prevent derps
Cursor.y = round(y);
if(CurrentTarget != noone){//We are targeting a character
    if(Action = 'Attack'){
        State = 'none';
        Action = 'none';
        AStar_free();
        ResetTiles();
        FindAttackRange(instance_position(x,y,objCell), Get_Battle_Stat_Total(self,'AttackRange'), Get_Battle_Stat_Total(self,'AttackLimit'), 1);//targets dont matter since we arent interested in the list
        FlashAttackTiles();
        
        var Index, Threat, MaxThreat;
        Index = 0;
        MaxThreat = 0;
        while(Index &lt; Cursor.NumberOfTargets){
            Threat = CalculateThreat(self.id,Cursor.AttackList[Index]);
            if(Threat &gt; MaxThreat){
                MaxThreat = Threat;
                CurrentTarget = Cursor.AttackList[Index];
            }
            Index += 1;
        }
        event_perform(ev_other,ev_user3);//face character in direction of target
            
        instance_create(0,0,EnemyTargetSelectionControler);
        EnemyTargetSelectionControler.Character = self.id;
        EnemyTargetSelectionControler.Target = CurrentTarget;
        EnemyTargetSelectionControler.Action = 'Attack';
        
        with(Cursor){//Pathfind with the cursor to the target
            visible = true;
            State = 'EnemyTargeting';
            AStar_init(global.RoomCellWidth,global.RoomCellHeight,24,24,0,0,1,0,-2,-2,0,0);
            myPath = -1;
        }
        Cursor.myPath = AStar_findPath(Cursor.x,Cursor.y,CurrentTarget.x,CurrentTarget.y,0);
        with(Cursor){  
            //State = 'Pathfinding';
            path_start(myPath,3,0,0);//speed 5?
            xstart = x;
            ystart = y;
        }
        CurrentTarget = noone;
    } 
    else if(Action = 'Magic'){
        State = 'none';
        Action = 'none';
        AStar_free();
        ResetTiles(); 
        FindAttackRange(instance_position(x,y,objCell),Get_Spell_Stats(Spells[SpellCast],SpellCastLevel,'SpellRange'),Get_Spell_Stats(Spells[SpellCast],SpellCastLevel,'SpellLimit'),1);
        FlashAttackTiles(); 
        
        var Index, Threat, MaxThreat;
        Index = 0;
        MaxThreat = 0;
        while(Index &lt; Cursor.NumberOfTargets){
            Threat = CalculateThreat(self.id,Cursor.AttackList[Index]);
            if(Threat &gt; MaxThreat){
                MaxThreat = Threat;
                CurrentTarget = Cursor.AttackList[Index];
            }
            Index += 1;
        }
        event_perform(ev_other,ev_user3);//face character in direction of target
             
        instance_create(0,0,EnemyTargetSelectionControler);
        EnemyTargetSelectionControler.Character = self.id;
        EnemyTargetSelectionControler.Target = CurrentTarget;
        EnemyTargetSelectionControler.Action = 'Magic';
        EnemyTargetSelectionControler.Spell = SpellCast;
        EnemyTargetSelectionControler.SpellLevel = SpellCastLevel;
        

        GetCursorSprite(Get_Spell_Stats(Spells[SpellCast], SpellCastLevel, 'Area'));
        
        
        with(Cursor){//Pathfind with the cursor to the target
            visible = true;
            State = 'EnemyTargeting';
            AStar_init(global.RoomCellWidth,global.RoomCellHeight,24,24,0,0,1,0,-2,-2,0,0);
            myPath = -1;
        }
        Cursor.myPath = AStar_findPath(Cursor.x,Cursor.y,CurrentTarget.x,CurrentTarget.y,0);
        with(Cursor){  
            //State = 'Pathfinding';
            path_start(myPath,3,0,0);//speed 5?
            xstart = x;
            ystart = y;
        }
        CurrentTarget = noone;
    }
}
else{//Otherwise we just end 
    AStar_free();
    direction = 270;
    State = 'none';
    Active = false;
    image_index = BattleControler.image_index; //keeps every character marching in sync
    ResetTiles();
    with(BattleControler){
        State = 'Stay';
        LEPanDirection = 'out';
        sound_play(MenuPanSound);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_sprite( sprite_index, image_index, x, y );

//draw_text(x,y,string(TurnNumber)); //Debug test
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
