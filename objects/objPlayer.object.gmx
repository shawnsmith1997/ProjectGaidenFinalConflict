<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-10</depth>
  <persistent>0</persistent>
  <parentName>objGuy</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Variables to assist actual grid movement
gridSize = 24;    // Set as power of 2 (1,2,4,8,16,32...)
isMoving = false; // True when player walking on grid
moveTimer = 0;    // Set to gridSize when move start
moveSpeed = 2.4;    // Set as Power of 24
speedX = 0;       // horizontal walking speed
speedY = 0;       // vertical walking speed

// Keep track of direction to change spriteindex
direction = 270; 

// Helpful for setting state after moving
justStoppedMoving = true;

Active = false; //Can we move the character?
xOrig = x; //Starting X position
yOrig = y; //Starting Y position
//Menu = false;
//HadTurn = false;
State = 'none';
Temp = 0;
IsTurn = false;
//IsAttacking = false;
GuyType = 'player';
OverwriteDeathEvent = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if(!OverwriteDeathEvent){//dont fire event if battle never starts
    //in case of death, fill its vacancy in the turn order with 'noone'
    FillDeathVoid(self.id);
    //Test if the death of this character loses the battle.
    BattleFailureFlagsScript(ID);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Death Script (makes the character spin and explode)
if (DeathState = 0){
direction = 180;

DeathState = 2;
alarm[3] = 2;
}
else if (DeathState = 2){
direction = 90;

DeathState = 3;
alarm[3] = 2;
}
else if (DeathState = 3){
direction = 0;

DeathState = 4;
alarm[3] = 2;
}
else if (DeathState = 4){
direction = 270;

DeathState = 5;
alarm[3] = 2;
}

else if (DeathState = 5){
direction = 180;

DeathState = 6;
alarm[3] = 2;
}
else if (DeathState = 6){
direction = 90;

DeathState = 7;
alarm[3] = 2;
}
else if (DeathState = 7){
direction = 0;

DeathState = 8;
alarm[3] = 2;
}
else if (DeathState = 8){
direction = 270;

DeathState = 9;
alarm[3] = 2;
}


else if (DeathState = 9){
direction = 180;

DeathState = 10;
alarm[3] = 2;
}
else if (DeathState = 10){
direction = 90;

DeathState = 11;
alarm[3] = 2;
}
else if (DeathState = 11){
direction = 0;

DeathState = 12;
alarm[3] = 2;
}
else if (DeathState = 12){
direction = 270;

DeathState = 13;
alarm[3] = 2;
}

else if(DeathState = 13){
instance_create(x,y,BoomObj);
instance_destroy();

}











</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>

if (State = 'WalkingToStartPosition'){ //Player is walking back to start position
    if (Cursor.x &lt; x){
        direction = 0;//Going Right
    }
    if (Cursor.x &gt; x){
        direction = 180;//Going Left
    }
    if (Cursor.y &lt; y){
        direction = 270;//Going Down
    }
    if (Cursor.y &gt; y){
        direction = 90;//Going Up
    }

    x = round(x);//Prevents a serious bug.
    y = round(y);//Basically it forces the cursor to be
    Cursor.x = x;//In sync with the player it's following.
    Cursor.y = y;

    Temp -= 3;
    if (Temp &lt;= 0)//Play step sound every tile
    {
        sound_play(StepSound);
        Temp = 24; //Size of tile.
    }
}

else if ((Active = true) &amp;&amp; (State = 'none') &amp;&amp; (Cursor.State = 'none')){    // Set standing animations if just stopped
    if (justStoppedMoving = true){
        justStoppedMoving = false;
    }
        
    //When not moving, check to see if a direction key is held.
    if (isMoving = false){        
             // Perform 4 direction keyboard and grid checks
             // for setting appropriate movement and animation
        if (keyboard_check(global.RightButton)){
            direction = 0; 
            if((place_free(x+24,y))&amp;&amp;((x+gridSize) &lt; room_width)){
                isMoving = true;      // Lets start moving
                moveTimer = gridSize; // Ready moveTimer for countdown
                speedX = moveSpeed;   // Set horizontal speed
                speedY = 0;           // Set vertical speed
                sound_play(StepSound);
            }
        }
        else if (keyboard_check(global.UpButton)){
            direction = 90;
            if((place_free(x,y-24))&amp;&amp;((y-gridSize) &gt;= 0)){
                isMoving = true;
                moveTimer = gridSize;
                speedX = 0;
                speedY = -moveSpeed;
                sound_play(StepSound);
            }
        }
        else if (keyboard_check(global.LeftButton)){
            direction = 180;
            if((place_free(x-24,y))&amp;&amp;((x-gridSize) &gt;= 0)){
                isMoving = true;
                moveTimer = gridSize;
                speedX = -moveSpeed;
                speedY = 0;
                sound_play(StepSound);
            } 
        }
        else
        if (keyboard_check(global.DownButton)){
            direction = 270;
            if((place_free(x,y+24))&amp;&amp;((y+gridSize) &lt; room_height)){
                isMoving = true;
                moveTimer = gridSize;
                speedX = 0;
                speedY = moveSpeed;
                sound_play(StepSound);
            }
        }
    
    }
    
        // When player is moving on grid...
    if (isMoving = true){
        x += speedX; // update our x/y positions
        y += speedY;
        moveTimer -= moveSpeed; // countdown moveTimer until 0, then stop moving
        if (moveTimer &lt;= 0){
        //sound_play(StepSound);
            isMoving = false;
            justStoppedMoving = true;
            x = round(x);//prevents a small visual issue at certain speeds
            y = round(y);
            //Update LandEffect window.
            with(BattleControler){
            event_perform(ev_other,ev_user1);
            }
            
        }
    }
    
    Cursor.x = x; //Keep Cursor and player in sync.
    Cursor.y = y;
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Event 11 finds the movement range of the player. It also remembers the players original location
//in case they decide to go back.

//x=xOrig; //in case player somehow "escaped" his tile
//y=yOrig;
//Cursor.x = x;//keep the cursor on the player 
//Cursor.y = y;
FindMovementRange(instance_position( xOrig , yOrig , objCell ), self.id);//find the player's movement range
FlashMoveTiles();//Display tile flashes
depth = -11; //Character appears to walk "on top of" other characters, not useful, just added eye candy.
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="8">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>MoveTimer = 0;//in case the GM engine derps up, (happens sometimes)
isMoving = false;//make sure it doesnt move when it's not supposed to

x = xOrig;//make sure player and cursor coordinates
y = yOrig;//are exactly the same as they should be
Cursor.x = x;//otherwise, crazy game breaking things
Cursor.y = y;//are bound to happen

//If (State = 1) walking back to start position
AStar_free();//Disable the path database
ResetTiles();//Turn off the flashing tiles.
direction = 270; //Face down
State = 'none'; //Make it so we can move again
sound_play(MenuPanSound);

Cursor.State = 'ManualMovement';//allow cursor to move
Cursor.visible = true;//Show Cursor

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>    draw_sprite( sprite_index, image_index, round(x), round(y) ); //This command just makes sure its drawn
    
    if ((Active)||(State = 'WalkingToStartPosition')){//If they are the active player, animate them faster.
    image_speed = .125;
    }
    else {//Otherwise just do the basic march speed.
    image_speed = .0625;
    }
    
    //draw_text(x,y,string(TurnNumber));

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
